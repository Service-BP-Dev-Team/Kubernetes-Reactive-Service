#the lenght to merge is greater than one (so it is at least 2)
---
kind : rule
name : Merge_Main_Incremental_Greater_Than_One_${array_size}
service: Merge_Main_S_${array_size}
guard :
 classPath: com.local.MergeIncremental
 method: lenght_is_greater_than_one
functions:
 - { classPath: com.local.Base, method: getZero, label: getZero}
 - { classPath: com.local.Base, method: incrementNumber, label: inc}
 - { classPath: com.local.MergeIncremental, method: divide_length, label: divide_length}
 - { classPath: com.local.MergeIncremental, method: init_indices, label: init_indices}
actions:
 - i = getZero()
 - pending_indices = init_indices(in_length)
 - out_length = divide_length(in_length)
 - out_arr[i/pending_indices] = [ Merge_Main_It_${array_size}(pending_indices,in_arr) for i,inc,${divide_array_size}]
 - (size,arr,merge_res) =  Merge_Main_S_${divide_array_size}(out_length,out_arr)
 
---
kind : rule
name : Merge_Main_Iterrator_${array_size}
service: Merge_Main_It_${array_size}
guard :
 classPath: com.local.MergeIncremental
 method: has_new_elements
 binding:
  - { name : list1 }
  - { name : list2 }
  - { name : next_indices }
functions:
 - { classPath: com.local.SortFunc, method: merge_sort, label: merge_two }
actions:
 - out = merge_two(list1,list2)
 - indices_out = next_indices
 
#service used by the main sort to merge incrementally the result
---
kind : service
name : Merge_Main_S_${array_size}
kubename : ${KUBE_NAME}
inputs : 
 - { name : in_length }
 - { name : in_arr, array: true, size: ${array_size} }
outputs :
 - { name : out_length}
 - { name : out_arr, array: true, size: ${divide_array_size}}
 - { name : merge_res}
 
---
kind : service
name : Merge_Main_It_${array_size}
kubename : ${KUBE_NAME}
inputs : 
 - { name : indices_in }
 - { name : in_arr, array: true, size: ${array_size} }
outputs :
 - { name : out}
 - { name : indices_out}
 

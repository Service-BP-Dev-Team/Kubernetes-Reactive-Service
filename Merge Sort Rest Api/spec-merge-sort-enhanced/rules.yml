---
# Service: MainSort --- 2 rules
# R1 is active when the list is long enough to distribute computation.
kind : rule
name : MainSort_remote
service : MainSort
guard : 
 classPath: com.local.SortFunc
 method: lengthgr
 # The guard requires a minimum length l+1 of the input list
functions :
 - { classPath: com.local.SortFunc, method: split, label: split, multiOutput: true, outputSize: 5}
 - { classPath: com.local.SortFunc, method: merge_f, label: merge_f}
 # update_values replaces some intentional values in out_list.
actions :
 - inp_array = split(inp_list)
 - out_array = RecSort(inp_array)
 - out_list = merge_f(out_array)

---
#R2 is active when the list is short enough to sort it locally
kind : rule
name : MainSort_local
service : MainSort
guard : 
 classPath: com.local.SortFunc
 method: lengthleq
 # The guard requires a maximum length l of the input list
functions :
 - { classPath: com.local.Base, method: sort, label: sort }
 # function from java.utils
actions :
 - out_list = sort(inp_list)



---
#R2 is active when the list is short enough to sort it locally
kind : rule
name : RecSort_local
service : RecSort
guard : 
 classPath: com.local.SortFunc
 method: lengthleq_in_arr
 # The guard requires a maximum length l-1 of the input list
functions :
 - { classPath: com.local.Base, method: sort_array_lists, label: sort_array_lists, multiOutput: true, outputSize: 5  }
actions :
 - out_arr = sort_array_lists(inp_arr)
 
---
#Service: RecSort -- 2 rules:
# R1 is active when the list is long enough to distribute computation.
kind : rule
name : RecSort_remote
service : RecSort
guard : 
 classPath: com.local.SortFunc
 method: lengthgr_in_arr
 # The guard requires a minimum length l of the input list
functions :
 - { classPath: com.local.SortFunc, method: divideLeft, label: divideLeft, multiOutput: true, outputSize: 5}
 - { classPath: com.local.SortFunc, method: divideRight, label: divideRight, multiOutput: true, outputSize: 5}
 - { classPath: com.local.SortFunc, method: init_indices, label: init_indices}
 - { classPath: com.local.Base, method: getZero, label: getZero}
 - { classPath: com.local.Base, method: incrementNumber, label: inc}
actions :
 - pending_indices = init_indices()
 - arr_left = divideLeft(inp_arr)
 - arr_right = divideRight(inp_arr) 
 - res_left = RecSort(arr_left)
 - res_right = RecSort(arr_right)
 - index = getZero()
 - out_arr[index/pending_indices] = [Merge_S(pending_indices,res_left,res_right) for index,inc,5]


---
kind : rule
name : merge_rule
service : Merge_S
guard:
 classPath: com.local.SortFunc
 method : has_new_elements
 binding: 
  - {name : list1}
  - {name : list2}
  - {name : remainingIndices}
functions : 
 - { classPath: com.local.SortFunc, method: merge_sort, label: merge_two }
actions :
 - indices_out = remainingIndices
 - out = merge_two(list1,list2)

# we need to add a rule to terminate the merge I think
